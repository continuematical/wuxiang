## 锁的作用

保障共享数据以实现线程安全；

### 通过互斥保障原子性

#### 互斥

一个锁只能被一个线程所拥有；

#### 原子性

1. 原子操作：该操作从执行线程外的任何线程来看是不可分割的，具有原子性；
2. Java语言规范long和double以外基础类型类型的变量的写操作都是原子操作；而对于long和double类型，一个线程可能读取到其他线程更新的中间结果；
3. 用volatile关键字修饰的long/double类型的写操作具有原子性

#### 实现原子性

1. 使用锁，在软件层次上实现；
2. 利用处理器提供的专门CAS指令，在硬件层次上实现；

### 保障可见性

#### 可见性

一个线程对某个共享变量进行更新后，后续访问该变量的线程可以读取到该更新的结果，则称这个线程对该共享变量的更新对其他线程可见；

#### 处理器

1. 通过**寄存器**，**高速缓存**，**写缓冲区**和**无效化队列**等部件执行内存的读和写操作的；
2. 处理器对主内存的访问是通过**高速缓存**子系统进行的；
3. 可见性问题和计算机的存储机制有关。如果两个线程分别运行在不同的处理器上，只有当共享变量存储在寄存器中时，才有可能实现可见性；即使变量分配到主内存也不能实现可见性，对共享变量的更新只会输入到处理器的写缓冲流中，而不是高速缓冲中，因此另一个线程·无法看到更新；即使写入高速缓存中，该处理器通知另一个线程时，通知信息只会被存入无效化队列中，而不会对变量进行更新；
4. 但是处理器可以通过缓存**一致性协议**读取其他处理器的高速缓存；
5. **缓存同步**：处理器从其他存储器读取数据并更新到自身高速缓存的过程；
6. 冲刷处理器缓存：处理器对共享变量的更新写入高速缓存和主内存中；
7. 刷新处理器缓存：从其他高速缓存或主内存中对变量进行缓存同步；
8. **相对新值**：一个线程更改了共享变量的值，其他线程能够读取到这个更新后的值；
9. **最新值**：线程无法更新该变量的值，那么线程读取到的相对新值就被称为该变量的最新值；

#### volatile

1. 提示编译器被修饰的变量可能被多个程序共享，阻止其对程序进行不必要的优化；

2. 被修饰的变量会使相应的处理器执行冲刷缓存的动作；

   **轻量级**

   仅仅保障写操作的原子性，没有锁的排他性，不会进行上下文切换；

#### 途径

通过线程冲刷处理器缓存和读取线程刷新处理器缓存实现的；

锁的获得：刷新处理器缓存，将对共享变量的更新写入缓存；

锁的释放：冲刷处理器缓存，将对共享变量的更新推送到线程处理器的高速缓存中；

### 保障有序性

#### 重排序

一个处理器上进行的多个操作，在其他处理器看来其顺序可能对目标代码顺序不同；

**相关概念**

源代码顺序

程序顺序

执行顺序

感知顺序

#### 分类

指令重排序

## 与锁相关的几个概念

#### 可重入性

线程持有锁时可以再次申请该锁；

**如何实现**

可重入锁可以被理解为一个对象，其中包含一个计数器。计数器的初始属性为0，每次获得锁，次数+1；初次获得锁后，可重入锁的持续进程开销会小的多。

#### 锁的争用和调度

**资源的争用和调度**

排他性资源：一次只能被一个线程占用，如数据库连接，处理器，文件等；

争用：一个线程占用一个排他性资源时，其他线程对该资源的争夺；

**调度策略**

1. 公平策略（外部锁）；
2. 非公平策略（内部锁，外部锁）；

#### 锁的粒度

粒度：一个锁实例所保护的共享变量的数量大小（粗/细）；

过粗：进行不必要的等待；

过细：增加锁调度的开销；

## 锁的开销和可能导致的问题

锁的开销包括锁的申请和释放；

### 故障

#### 锁泄露

定义：一个线程获得该锁后，由于程序的错误而导致该锁一直无法释放，其他线程一直无法获得该锁的情况；

## 锁的分类

### 内部锁

### 外部锁

# 线程同步机制：内存保障

## 分类

### 可见性保护屏障

1. 加载屏障：刷新处理器缓存

2. 存储屏障：冲刷处理器缓存

### 有序性保障

1. 获取屏障：读操作之后插入，禁止该读操作与其后的任何读写操作排序；

2. 释放屏障：写操作前插入，禁止该写操作与前面的任何读写操作排序；

# 锁与重排序